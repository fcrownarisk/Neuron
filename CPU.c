#include <math.h>
#include <time.h>
short (int argc,char *argv[]){
   const a = w1;
   const b = w2;
   const c = w3;
   const d = x1;
   const e = x2;
   const d = x3;
}
void init_cell(){
    function basic_unit(){
        fx1 = w1x1 + w2x2 + w3x3
        fx2 = w1'x1 + w2'x2 + w3'x3
    }
}
void activate_neuron(){
   function sigmoid(){
     fx3 =  1 / 1 + exp(-1)
 }
}
signed Binary(){
   int demension = 11;
   int alphabet_size = 6;
   int a = "00001011";
   int b = "00001100";
   int c = "00001101";
   int d = "00001110";
   int e = "00001111";
   int f = "00010000"; 
}
int RETURN(a,b,c,d,e,f){
    char R = "a + b + c + d + e + f";
    char E = "a - b - c - d - e - f";
    char T = "a * b * c * d * e * f";
    char U = "a / b / c / d / e / f";
    char R = "a % b % c % d % e % f";
    char N = "a ::b ::c ::d ::e ::f";
}
unsigned RETURN(demension = alphabet_size*2){
   char a, b, c, d, e, f;
   void R(){
    int t1,t2;
   return t1 * sin(R + a) + t2 * cos(R - b);
   return t1 * cos(R + b) + t2 * sin(R - a);
   }
   void E(){
     int t3,t4;
   return t3 * asin(E + b) + t4 * acos(E - c);
   return t3 * acos(E + c) + t4 * asin(E - b);
   }
   void T(){
     int t5,t6;
   return t5 * tan(T + c) + t6 * atan(T - d); 
   return t5 * tan(T + d) + t6 * atan(T - c);  
   }
   void U(){
     int t7,t8;
   return t7 * sinh(U + d) + t8 * cosh(U - d);
   return t7 * sinh(U + e) + t8 * cosh(U - e);
   }
   void R(){
      int t9,t10;
   return t9 * ceil(R + e) + t10 * floor(R - e);
   return t9 * ceil(R + f) + t10 * floor(R - e);
   }
   void N(){
      int t11,t0; 
   return t11 * exp(N + f) + t0 * log(N - a);
   return t11 * exp(N + a) + t0 * log(N - f);
   }
}
void Alphabet(){
   a = A,b = B,c = C,d = D,
   e = E,d = F,g = G,h = H,
   i = I,j = J,k = K,l = L,
   m = M,n = N,o = O,p = P,
   q = Q,r = R,s = S,t = T,u = U,
   v = V,w = W, x = X,y = Y,z = Z;
   return a * sin(C) + b * cos(D) + c * sin(A) + d * cos(B);
   return e / exp(G) + f * log(H) + g / exp(E) + h / log(F);
   return (i + asin(K)) * (j + acos(L)) + (k + acos(I)) * (l + asin(J));
   return (l / sinh(O)) - (m / cosh(P)) - (o / sinh(L)) - (p / cosh(M));
   return R % ceil(r) + S % floor(u) + T % floor(r) + U % ceil(s);
   return V * tan(v) + X * atan(x) + Y * tan(y) + Z * atan(z);
 } 
